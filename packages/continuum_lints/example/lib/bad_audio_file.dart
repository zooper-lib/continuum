import 'package:continuum/continuum.dart';

/// Example event type used by the lint demonstration.
///
/// This event intentionally has no generator annotations because the lint rule
/// only cares about `apply<Event>(...)` handlers declared by the generated
/// `_$<Aggregate>EventHandlers` mixin.
sealed class AudioFileDeletedEvent implements ContinuumEvent {
  /// Creates a test event instance.
  const AudioFileDeletedEvent();
}

/// Mimics the mixin that would normally be generated by `continuum_generator`.
///
/// The lint rule derives required handlers from the abstract methods declared
/// on this mixin.
mixin _$AudioFileEventHandlers {
  /// Applies an [AudioFileDeletedEvent] to the aggregate.
  void applyAudioFileDeletedEvent(AudioFileDeletedEvent event);
}

/// Demonstrates the lint: this class is concrete, annotated with `@Aggregate()`,
/// mixes in `_$AudioFileEventHandlers`, but does not implement the required
/// apply method.
@Aggregate()
class AudioFile with _$AudioFileEventHandlers {
  /// Creates an [AudioFile].
  const AudioFile();

  /// Implements `noSuchMethod` so the class can remain concrete even though it
  /// does not implement all interface members.
  ///
  /// Why this matters for the example:
  /// - Without this, the analyzer may surface a hard error for missing
  ///   implementations.
  /// - With this, the class can still type-check, but it would fail at runtime
  ///   if `applyAudioFileDeletedEvent` is invoked.
  /// - The lint provides actionable feedback earlier than runtime.
  @override
  dynamic noSuchMethod(Invocation invocation) {
    return super.noSuchMethod(invocation);
  }
}
