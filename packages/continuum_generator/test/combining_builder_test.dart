import 'dart:isolate';

import 'package:build/build.dart';
import 'package:build_test/build_test.dart';
import 'package:continuum_generator/builder.dart';
import 'package:package_config/package_config.dart';
import 'package:test/test.dart';

void main() {
  late final PackageConfig packageConfig;
  late TestReaderWriter readerWriter;

  setUpAll(() async {
    final uri = await Isolate.packageConfig;
    if (uri == null) {
      throw StateError('Missing Isolate.packageConfig; cannot run build_test in a pub workspace.');
    }

    packageConfig = await loadPackageConfigUri(uri);
  });

  setUp(() async {
    readerWriter = TestReaderWriter(rootPackage: 'continuum_generator');
    await readerWriter.testing.loadIsolateSources();
  });

  group('CombiningBuilder', () {
    test('generates lib/continuum.g.dart for aggregate roots', () async {
      // Arrange: Provide a synthetic `$lib$` input and a single annotated
      // aggregate. This verifies the happy path where at least one aggregate
      // exists and a combining output should be produced.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: The output should exist and contain expected imports and
      // the aggregate registration entry.
      await testBuilder(
        builder,
        {
          'continuum_generator|lib/user.dart': """
import 'package:bounded/bounded.dart';

final class UserId extends TypedIdentity<String> {
  const UserId(super.value);
}

class User extends AggregateRoot<UserId> {
  User(super.id);
}
""",
        },
        rootPackage: 'continuum_generator',
        packageConfig: packageConfig,
        readerWriter: readerWriter,
        outputs: {
          'continuum_generator|lib/continuum.g.dart': decodedMatches(
            allOf(
              contains("import 'package:continuum/continuum.dart';"),
              contains("import 'user.dart';"),
              contains(r'final List<GeneratedAggregate> $aggregateList = ['),
              contains(r'  $User,'),
            ),
          ),
        },
      );
    });

    test('skips Freezed-like part files and still generates output', () async {
      // Arrange: A common real-world case is a generated `*.freezed.dart` file
      // under `lib/` that is a `part of` file (not a standalone library).
      // The builder must skip it to avoid `Asset ... is not a Dart library`.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: Build succeeds and output is generated.
      await testBuilder(
        builder,
        {
          'continuum_generator|lib/user.dart': """
import 'package:bounded/bounded.dart';

final class UserId extends TypedIdentity<String> {
  const UserId(super.value);
}

class User extends AggregateRoot<UserId> {
  User(super.id);
}
""",
          'continuum_generator|lib/repository_error.dart': """
part 'repository_error.freezed.dart';

class RepositoryError {}
""",
          'continuum_generator|lib/repository_error.freezed.dart': """
part of 'repository_error.dart';

// Intentionally minimal. In real apps this file is generated by Freezed.
""",
        },
        rootPackage: 'continuum_generator',
        packageConfig: packageConfig,
        readerWriter: readerWriter,
        outputs: {
          'continuum_generator|lib/continuum.g.dart': decodedMatches(
            allOf(
              contains("import 'user.dart';"),
              contains(r'  $User,'),
            ),
          ),
        },
      );
    });

    test('skips non-library part files even without generated suffix', () async {
      // Arrange: Not all part files end with known generated suffixes.
      // This validates the `resolver.isLibrary(...)` guard.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: Build succeeds and output is generated.
      await testBuilder(
        builder,
        {
          'continuum_generator|lib/user.dart': """
import 'package:bounded/bounded.dart';

final class UserId extends TypedIdentity<String> {
  const UserId(super.value);
}

class User extends AggregateRoot<UserId> {
  User(super.id);
}
""",
          'continuum_generator|lib/odd_library.dart': """
part 'odd_part.dart';

class OddLibrary {}
""",
          'continuum_generator|lib/odd_part.dart': """
part of 'odd_library.dart';

class OddPart {}
""",
        },
        rootPackage: 'continuum_generator',
        packageConfig: packageConfig,
        readerWriter: readerWriter,
        outputs: {
          'continuum_generator|lib/continuum.g.dart': decodedMatches(
            contains(r'  $User,'),
          ),
        },
      );
    });

    test('does not generate output when no aggregates exist', () async {
      // Arrange: If no aggregate roots exist, emitting an empty
      // `continuum.g.dart` would be surprising for users.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: No outputs should be written.
      await testBuilder(
        builder,
        {
          'continuum_generator|lib/not_an_aggregate.dart': '''
class NotAnAggregate {}
''',
        },
        rootPackage: 'continuum_generator',
        packageConfig: packageConfig,
        readerWriter: readerWriter,
        outputs: const {},
      );
    });
  });
}
