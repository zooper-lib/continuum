import 'dart:io';
import 'dart:isolate';

import 'package:build/build.dart';
import 'package:build_test/build_test.dart';
import 'package:continuum_generator/builder.dart';
import 'package:package_config/package_config.dart';
import 'package:test/test.dart';

void main() {
  late final PackageConfig packageConfig;
  late TestReaderWriter readerWriter;

  setUpAll(() async {
    // In some CI environments (notably when running tests via workspace tooling),
    // `Isolate.packageConfig` can be null. Fall back to locating the
    // `.dart_tool/package_config.json` file relative to the working directory.
    Uri? packageConfigUri = await Isolate.packageConfig;
    packageConfigUri ??= _tryFindPackageConfigUriFromWorkingDirectory();

    if (packageConfigUri == null) {
      throw StateError(
        'Missing package config. `Isolate.packageConfig` was null and no '
        '`.dart_tool/package_config.json` could be found from `${Directory.current.path}`.',
      );
    }

    packageConfig = await loadPackageConfigUri(packageConfigUri);
  });

  setUp(() async {
    readerWriter = TestReaderWriter(rootPackage: 'continuum_generator');
    await readerWriter.testing.loadIsolateSources();
  });

  group('CombiningBuilder', () {
    test('generates lib/continuum.g.dart for aggregate roots', () async {
      // Arrange: Provide a synthetic `$lib$` input and a single annotated
      // aggregate. This verifies the happy path where at least one aggregate
      // exists and a combining output should be produced.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: The output should exist and contain expected imports and
      // the aggregate registration entry.
      await testBuilder(
        builder,
        {
          'continuum_generator|lib/user.dart': """
import 'package:bounded/bounded.dart';

final class UserId extends TypedIdentity<String> {
  const UserId(super.value);
}

class User extends AggregateRoot<UserId> {
  User(super.id);
}
""",
        },
        rootPackage: 'continuum_generator',
        packageConfig: packageConfig,
        readerWriter: readerWriter,
        outputs: {
          'continuum_generator|lib/continuum.g.dart': decodedMatches(
            allOf(
              contains("import 'package:continuum/continuum.dart';"),
              contains("import 'user.dart';"),
              contains(r'final List<GeneratedAggregate> $aggregateList = ['),
              contains(r'  $User,'),
            ),
          ),
        },
      );
    });

    test('skips Freezed-like part files and still generates output', () async {
      // Arrange: A common real-world case is a generated `*.freezed.dart` file
      // under `lib/` that is a `part of` file (not a standalone library).
      // The builder must skip it to avoid `Asset ... is not a Dart library`.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: Build succeeds and output is generated.
      await testBuilder(
        builder,
        {
          'continuum_generator|lib/user.dart': """
import 'package:bounded/bounded.dart';

final class UserId extends TypedIdentity<String> {
  const UserId(super.value);
}

class User extends AggregateRoot<UserId> {
  User(super.id);
}
""",
          'continuum_generator|lib/repository_error.dart': """
part 'repository_error.freezed.dart';

class RepositoryError {}
""",
          'continuum_generator|lib/repository_error.freezed.dart': """
part of 'repository_error.dart';

// Intentionally minimal. In real apps this file is generated by Freezed.
""",
        },
        rootPackage: 'continuum_generator',
        packageConfig: packageConfig,
        readerWriter: readerWriter,
        outputs: {
          'continuum_generator|lib/continuum.g.dart': decodedMatches(
            allOf(
              contains("import 'user.dart';"),
              contains(r'  $User,'),
            ),
          ),
        },
      );
    });

    test('skips non-library part files even without generated suffix', () async {
      // Arrange: Not all part files end with known generated suffixes.
      // This validates the `resolver.isLibrary(...)` guard.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: Build succeeds and output is generated.
      await testBuilder(
        builder,
        {
          'continuum_generator|lib/user.dart': """
import 'package:bounded/bounded.dart';

final class UserId extends TypedIdentity<String> {
  const UserId(super.value);
}

class User extends AggregateRoot<UserId> {
  User(super.id);
}
""",
          'continuum_generator|lib/odd_library.dart': """
part 'odd_part.dart';

class OddLibrary {}
""",
          'continuum_generator|lib/odd_part.dart': """
part of 'odd_library.dart';

class OddPart {}
""",
        },
        rootPackage: 'continuum_generator',
        packageConfig: packageConfig,
        readerWriter: readerWriter,
        outputs: {
          'continuum_generator|lib/continuum.g.dart': decodedMatches(
            contains(r'  $User,'),
          ),
        },
      );
    });

    test('does not generate output when no aggregates exist', () async {
      // Arrange: If no aggregate roots exist, emitting an empty
      // `continuum.g.dart` would be surprising for users.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: No outputs should be written.
      await testBuilder(
        builder,
        {
          'continuum_generator|lib/not_an_aggregate.dart': '''
class NotAnAggregate {}
''',
        },
        rootPackage: 'continuum_generator',
        packageConfig: packageConfig,
        readerWriter: readerWriter,
        outputs: const {},
      );
    });
  });
}

/// Attempts to locate the workspace `.dart_tool/package_config.json` file.
///
/// CI and workspace runners can launch `dart test` in ways where
/// `Isolate.packageConfig` is unavailable. In those cases, build_test still
/// needs a real package config to resolve `package:` imports.
Uri? _tryFindPackageConfigUriFromWorkingDirectory() {
  Directory currentDirectory = Directory.current;
  while (true) {
    final Uri candidateUri = currentDirectory.uri.resolve('.dart_tool/package_config.json');
    if (File.fromUri(candidateUri).existsSync()) {
      return candidateUri;
    }

    final Directory parentDirectory = currentDirectory.parent;
    if (parentDirectory.path == currentDirectory.path) {
      return null;
    }

    currentDirectory = parentDirectory;
  }
}
