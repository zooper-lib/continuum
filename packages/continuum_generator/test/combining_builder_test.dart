import 'package:build/build.dart';
import 'package:build_test/build_test.dart';
import 'package:continuum_generator/builder.dart';
import 'package:test/test.dart';

const _aggregateAnnotationSource = '''
/// Marks a class as an event-sourced aggregate root.
///
/// When the generator scans the library, classes annotated with `@Aggregate()`
/// are treated as aggregate candidates for code generation.
class Aggregate {
  /// Creates an aggregate annotation.
  const Aggregate();
}
''';

void main() {
  group('CombiningBuilder', () {
    test('generates lib/continuum.g.dart for @Aggregate classes', () async {
      // Arrange: Provide a synthetic `$lib$` input and a single annotated
      // aggregate. This verifies the happy path where at least one aggregate
      // exists and a combining output should be produced.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: The output should exist and contain expected imports and
      // the aggregate registration entry.
      await testBuilder(
        builder,
        {
          'continuum|lib/src/annotations/aggregate.dart': _aggregateAnnotationSource,
          'continuum_generator|lib/user.dart': """
import 'package:continuum/src/annotations/aggregate.dart';

@Aggregate()
class User {}
""",
        },
        rootPackage: 'continuum_generator',
        outputs: {
          'continuum_generator|lib/continuum.g.dart': decodedMatches(
            allOf(
              contains("import 'package:continuum/continuum.dart';"),
              contains("import 'user.dart';"),
              contains(r'final List<GeneratedAggregate> $aggregateList = ['),
              contains(r'  $User,'),
            ),
          ),
        },
      );
    });

    test('skips Freezed-like part files and still generates output', () async {
      // Arrange: A common real-world case is a generated `*.freezed.dart` file
      // under `lib/` that is a `part of` file (not a standalone library).
      // The builder must skip it to avoid `Asset ... is not a Dart library`.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: Build succeeds and output is generated.
      await testBuilder(
        builder,
        {
          'continuum|lib/src/annotations/aggregate.dart': _aggregateAnnotationSource,
          'continuum_generator|lib/user.dart': """
import 'package:continuum/src/annotations/aggregate.dart';

@Aggregate()
class User {}
""",
          'continuum_generator|lib/repository_error.dart': """
part 'repository_error.freezed.dart';

class RepositoryError {}
""",
          'continuum_generator|lib/repository_error.freezed.dart': """
part of 'repository_error.dart';

// Intentionally minimal. In real apps this file is generated by Freezed.
""",
        },
        rootPackage: 'continuum_generator',
        outputs: {
          'continuum_generator|lib/continuum.g.dart': decodedMatches(
            allOf(
              contains("import 'user.dart';"),
              contains(r'  $User,'),
            ),
          ),
        },
      );
    });

    test('skips non-library part files even without generated suffix', () async {
      // Arrange: Not all part files end with known generated suffixes.
      // This validates the `resolver.isLibrary(...)` guard.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: Build succeeds and output is generated.
      await testBuilder(
        builder,
        {
          'continuum|lib/src/annotations/aggregate.dart': _aggregateAnnotationSource,
          'continuum_generator|lib/user.dart': """
import 'package:continuum/src/annotations/aggregate.dart';

@Aggregate()
class User {}
""",
          'continuum_generator|lib/odd_library.dart': """
part 'odd_part.dart';

class OddLibrary {}
""",
          'continuum_generator|lib/odd_part.dart': """
part of 'odd_library.dart';

class OddPart {}
""",
        },
        rootPackage: 'continuum_generator',
        outputs: {
          'continuum_generator|lib/continuum.g.dart': decodedMatches(
            contains(r'  $User,'),
          ),
        },
      );
    });

    test('does not generate output when no aggregates exist', () async {
      // Arrange: If no `@Aggregate()` classes exist, emitting an empty
      // `continuum.g.dart` would be surprising for users.
      final builder = continuumCombiningBuilder(const BuilderOptions({}));

      // Act + Assert: No outputs should be written.
      await testBuilder(
        builder,
        {
          'continuum_generator|lib/not_an_aggregate.dart': '''
class NotAnAggregate {}
''',
        },
        rootPackage: 'continuum_generator',
        outputs: const {},
      );
    });
  });
}
